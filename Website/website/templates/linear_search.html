{% extends "content.html" %} {% block title %} Linear Search {% endblock %} {% block main_content %}
<h1>Linear Search</h1>
<p>
    Linear search is a <strong>simple algorithm</strong> used for finding a particular item within a list or array. It
    operates by <strong>sequentially checking each item</strong> in the list until the desired query has been found.
</p>

<div class="subcontent">
    <h3>Python Implementation & Visualization</h3>
    <div class="visualization-container">
        <div class="code-block">
            <button class="copy-btn" onclick="copyToClipboard(this)">
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    height="24px"
                    viewBox="0 -960 960 960"
                    width="24px"
                    fill="#e3e3e3"
                >
                    <path
                        d="M120-220v-80h80v80h-80Zm0-140v-80h80v80h-80Zm0-140v-80h80v80h-80ZM260-80v-80h80v80h-80Zm100-160q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480Zm40 240v-80h80v80h-80Zm-200 0q-33 0-56.5-23.5T120-160h80v80Zm340 0v-80h80q0 33-23.5 56.5T540-80ZM120-640q0-33 23.5-56.5T200-720v80h-80Zm420 80Z"
                    />
                </svg>
            </button>
            <pre id="code-block" class="line-numbers language-python line-highlight" data-start="1" data-line="1">
    <code>def search(arr, N, x):
        for i in range(0, N):
            if (arr[i] == x):
                return i
        return -1

    # Function call
    arr = [5, 2, 4, 6, 3, 1]
    N = len(arr)
    x = 6
    result = search(arr, N, x)</code>
    </pre>
        </div>
        <div class="video-container">
            <video id="code-video" width="640" controls>
                <source src="{{ url_for('static', filename='videos/LinearSearch.mp4') }}" type="video/mp4" />
                Your browser does not support the video tag.
            </video>
        </div>
    </div>
</div>

<div class="subcontent">
    <h3>Use Cases and Applications</h3>
    <ul>
        <li>
            <strong>Simple lists</strong>: Linear search is suitable for <strong>small lists or unsorted data</strong>,
            where the overhead of more complex algorithms like binary search (which requires sorted data) is not
            justified.
        </li>
        <li>
            <strong>Searching for elements</strong>: It can be used to
            <strong>determine if an element <code>x</code> is present</strong> in an array.
        </li>
        <li>
            <strong>Checking for absence</strong>: The worst-case scenario for linear search often occurs when the
            element being sought is <strong>not present</strong> in the array.
        </li>
        <li>
            <strong>Finding an equilibrium price</strong>: In certain economic problems, if the search space is
            monotonic, binary search is more efficient, implying linear search would be <em>infeasible</em> for very
            large search spaces like 1 to 10. This highlights that linear search is generally for <em>smaller</em> or
            <em>unstructured</em> problems where its simplicity is an advantage.
        </li>
    </ul>
</div>

<div class="subcontent">
    <h3>Time Complexity</h3>
    <p>
        The time complexity of an algorithm indicates how its running time increases with the size of the input, usually
        denoted as <code>N</code>.
    </p>
    <ul>
        <li>
            <strong>General Complexity: $O(n)$</strong>
            <ul>
                <li>
                    Linear search is categorised as a
                    <strong>linear algorithm</strong>, with a complexity of <strong>$O(n)$</strong>. This means the
                    number of operations performed is directly proportional to the number of items <code>N</code> to be
                    traversed.
                </li>
                <li>
                    Big O notation focuses on the
                    <strong>worst-case scenario</strong> to provide a reassurance that the algorithm will never be
                    slower than the stated time.
                </li>
            </ul>
        </li>
        <li>
            <strong>Worst-Case Analysis: $\Theta(n)$</strong>
            <ul>
                <li>
                    In the worst case, the element being searched for is
                    <strong>not present in the array</strong>. Alternatively, it could be the
                    <strong>very last element</strong> in the list.
                </li>
                <li>
                    The <code>search()</code> function compares the target element with
                    <strong>all <code>N</code> elements</strong> of the array, one by one.
                </li>
                <li>
                    Therefore, the worst-case time complexity of linear search is
                    <strong>$\Theta(n)$</strong>. This provides an <strong>upper bound</strong> on the running time,
                    guaranteeing the algorithm will never take longer.
                </li>
                <li>
                    For example, searching a list of 4 billion numbers could take up to 4 billion comparisons in linear
                    time.
                </li>
            </ul>
        </li>
        <li>
            <strong>Average-Case Analysis: $\Theta(n)$</strong>
            <ul>
                <li>
                    In average-case analysis, the computing time is calculated by considering
                    <strong>all possible inputs</strong>.
                </li>
                <li>
                    Assuming that all cases are
                    <strong>uniformly distributed</strong> (including the case where the element is not present), the
                    average case involves summing the times for all possibilities and dividing by the total number of
                    inputs (n+1 for linear search).
                </li>
                <li>
                    The average-case running time for linear search is a
                    <strong>quadratic function</strong> of the input size (if you consider the total work, but in terms
                    of Big O, it simplifies to $O(n)$).
                </li>
                <li>
                    Thus, the average-case time complexity of linear search is
                    <strong>$\Theta(n)$</strong>.
                </li>
            </ul>
        </li>
        <li>
            <strong>Best-Case Analysis: $\Theta(1)$</strong>
            <ul>
                <li>
                    The best case occurs when the element <code>x</code> is found at the
                    <strong>first location</strong> in the array.
                </li>
                <li>
                    The number of operations in this scenario is
                    <strong>constant</strong> (not dependent on <code>N</code>).
                </li>
                <li>So, the best-case time complexity is <strong>$\Theta(1)$</strong>.</li>
                <li>
                    However, the best-case analysis is generally considered "bogus" because guaranteeing a lower bound
                    provides
                    <strong>little useful information</strong>, as an algorithm might still take a very long time in its
                    worst case.
                </li>
            </ul>
        </li>
    </ul>
</div>
<div class="subcontent">
    <h3>Space Complexity</h3>
    <ul>
        <li>
            Linear search typically uses a
            <strong>constant amount of auxiliary memory</strong>, which means its space complexity is
            <strong>$O(1)$</strong>. It does not require additional data structures that grow with the input size.
        </li>
    </ul>
</div>
<div class="subcontent">
    <h3>Advantages</h3>
    <ul>
        <li>
            <strong>Simplicity</strong>: Linear search is a <strong>simple algorithm</strong> to understand and
            implement.
        </li>
        <li>
            <strong>No Sorting Required</strong>: Unlike binary search, linear search
            <strong>does not require the input list to be sorted</strong>. This is crucial for unsorted data, where
            pre-sorting would add significant time complexity (e.g., $O(n \log{n})$ for sorting).
        </li>
        <li><strong>Guaranteed to find</strong>: If the element exists in the list, it will eventually be found.</li>
    </ul>
</div>
<div class="subcontent">
    <h3>Disadvantages</h3>
    <ul>
        <li>
            <strong>Inefficiency on Large Data</strong>: Linear search is
            <strong>inefficient for large lists</strong> or search spaces because its running time grows linearly with
            the input size.
        </li>
        <li>
            <strong>Worst-Case Performance</strong>: In the worst case, it has to traverse the entire list, making it
            very slow for practical applications on large datasets.
        </li>
        <li>
            <strong>Cannot leverage sorted data</strong>: Even if the data is sorted, linear search does not take
            advantage of this order to speed up the search process, unlike binary search.
        </li>
    </ul>
</div>

<script>
    document.addEventListener("DOMContentLoaded", () => {
        const video = document.getElementById("code-video");
        const codeBlock = document.getElementById("code-block");

        // Time-to-line mapping
        const highlightMap = [
            { time: 0.0, lines: "1" },
            //Check 5
            { time: 0.6, lines: "2" },
            { time: 0.8, lines: "3" },
            // Check 2
            { time: 1.55, lines: "2" },
            { time: 1.82, lines: "3" },
            // Check 4
            { time: 2.6, lines: "2" },
            { time: 3, lines: "3" },
            // Check 6
            { time: 3.8, lines: "2" },
            { time: 4.2, lines: "3" },
            { time: 5, lines: "4" },
            // return
            { time: 7, lines: "11" },
        ];

        video.addEventListener("timeupdate", () => {
            const currentTime = video.currentTime;
            // console.log(`At ${currentTime.toFixed(3)}s`);
            let currentHighlight = "";

            for (let i = highlightMap.length - 1; i >= 0; i--) {
                if (currentTime >= highlightMap[i].time) {
                    currentHighlight = highlightMap[i].lines;
                    break;
                }
            }

            if (codeBlock.getAttribute("data-line") !== currentHighlight) {
                codeBlock.setAttribute("data-line", currentHighlight);
                Prism.highlightElement(codeBlock.querySelector("code"));
            }
        });
    });

    function copyToClipboard(button) {
        const pre = button.closest(".code-block");
        const code = pre?.querySelector("code");
        if (!code) return;

        // Create a temporary textarea to hold the code text
        const tempTextarea = document.createElement("textarea");
        tempTextarea.value = code.innerText;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        document.execCommand("copy");
        document.body.removeChild(tempTextarea);

        // Optionally give user feedback
        button.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e3e3e3"><path d="M382-320 155-547l57-57 170 170 366-366 57 57-423 423ZM200-160v-80h560v80H200Z"/></svg>
        `;
        setTimeout(() => {
            button.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e3e3e3">
            <path d="M120-220v-80h80v80h-80Zm0-140v-80h80v80h-80Zm0-140v-80h80v80h-80ZM260-80v-80h80v80h-80Zm100-160q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480Zm40 240v-80h80v80h-80Zm-200 0q-33 0-56.5-23.5T120-160h80v80Zm340 0v-80h80q0 33-23.5 56.5T540-80ZM120-640q0-33 23.5-56.5T200-720v80h-80Zm420 80Z"/>
        </svg>`;
        }, 1000);
    }
</script>
{% endblock %}
